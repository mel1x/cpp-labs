# Лабораторная работа №1 Жукова Михила ИТ-1-2024 Вариант 6

# task2/

# Лабораторная работа №1 Вариант 6
## Задание 1.2 Методы


### Постановка задачи
Сумма знаков.  
Дана сигнатура функции: `int sumLastNums (int x);`  
Необходимо реализовать функцию таким образом, чтобы она возвращала  
результат сложения двух последних знаков числа х, предполагая, что знаков в  
числе не менее двух. Подсказки:  
```
int x=123%10; // х будет иметь значение 3
int у=123/10; // у будет иметь значение 12
```
Пример:  
```
x=4568
результат: 14
```

### Алгоритм решения
1. Получаю последний знак числа взяв x % 10
2. Получаю предпоследний знак числа взяв (x/10) % 10
3. Возвращаю модуль суммы последних знаков

### Тесты
```
sumLastNums(-133) == 6; // true
sumLastNums(12) == 3; // true
```


# task4/

# Лабораторная работа №1 Вариант 6
## Задание 1.4 Методы


### Постановка задачи
Есть ли позитив.  
Дана сигнатура функции: `bool isPositive (int x);`  
Необходимо реализовать функцию таким образом, чтобы она принимала число  
x и возвращала true, если оно положительное.  
Пример 1:  
```
x=3
результат: true
```
Пример 2:  
```
x=-5
результат: false
```

### Алгоритм решения
1. Возвращаю результат сравнения x > 0

### Тесты
```
isPositive(-23) == false; // true
isPositive(43) == true; // true
```


# task6/

# Лабораторная работа №1 Вариант 6
## Задание 1.6 Методы


### Постановка задачи
Большая буква.  
Дана сигнатура функции: `bool isUpperCase (char x);`  
Необходимо реализовать функцию таким образом, чтобы она принимала  
символ x и возвращала true, если это большая буква в диапазоне от ‘A’ до ‘Z’.  
Пример 1:  
```
x=’D’  
результат: true  
```
Пример 2:  
```
x=’q’  
результат: false  
```

### Алгоритм решения
1. Получаю код символа x, приводя его к типу int
2. Проверяю, попадает ли код символа в один из диапазонов заглавных букв:
   - Английские заглавные буквы: коды от 65 до 90 (A-Z)
   - Русские заглавные буквы: коды от 1040 до 1071 (А-Я)
   - Русская заглавная буква Ё: код 1025
3. Если код символа попадает в любой из этих диапазонов, возыращаю true
4. Иначе возвращаю false

### Тесты
```
isUpperCase('Ё') == true; // true
isUpperCase('ё') == false; // true
isUpperCase('L') == true; // true
isUpperCase('l') == false; // true
```



# task8/

# Лабораторная работа №1 Вариант 6
## Задание 1.8 Методы


### Постановка задачи
Делитель.  
Дана сигнатура функции: `bool isDivisor (int a, int b);`  
Необходимо реализовать функцию таким образом, чтобы она возвращала true,  
если любое из принятых чисел делит другое нацело.  
Пример 1:  
```
a=3 b=6  
результат: true  
```
Пример 2:  
```
a=2 b=15  
результат: false  
```

### Алгоритм решения
1. Проверяю является ли хотя бы одно из чисел 0
2. Проверяю делимость a/b и b/a
3. Возвращаю true если хотя бы одна из делимостей выполняется

### Тесты
```
isDivisor(3,6) == true; // true
isDivisor(2,15) == false; // true
isDivisor(2,0) == false; // true
```


# task10/

# Лабораторная работа №1 Вариант 6
## Задание 1.10 Методы


### Постановка задачи
Многократный вызов.  
Дана сигнатура функции: `int lastNumSum(int a, int b)`  
Необходимо реализовать функцию таким образом, чтобы она считала сумму  
цифр двух чисел из разряда единиц. Выполните с его помощью  
последовательное сложение пяти чисел и результат выведите на экран.  
Постарайтесь выполнить задачу, используя минимально возможное  
количество вспомогательных переменных.  
Пример:  
```
5+11 это 6
6+123 это 9
9+14 это 13
13+1 это 4
Итого 4
```

### Алгоритм решения
1. Возвращаю сумму моудлей еденичных разрядов a%10 и b%10

### Тесты
```
lastNumSum(3,6) == 9; // true
lastNumSum(322,15) == 7; // true
lastNumSum(-232,0) == 2; // true
```



# task12/

# Лабораторная работа №1 Вариант 6
## Задание 2.2 Условия


### Постановка задачи
Безопасное деление.  
Дана сигнатура функции: `double safeDiv (int x, int y);`  
Необходимо реализовать функцию таким образом, чтобы она возвращала  
деление x на y, и при этом гарантировала, что не будет выкинута ошибка  
деления на 0. При делении на 0 следует вернуть из функции число 0. Подсказка:  
смотри ограничения на операции типов данных.  
Пример 1:  
```
x=5 y=0
результат: 0
```
Пример 2:
```
x=8 y=2
результат: 4
```

### Алгоритм решения
1. Проверяю знаменатель на 0
2. Возвращаю результат деления

### Тесты
```
safeDiv(13,2) == 6.5; // true
safeDiv(0,23) == 0; // true
safeDiv(213,0) == 0; // true
```



# task14/

# Лабораторная работа №1 Вариант 6
## Задание 2.4 Условия


### Постановка задачи
Строка сравнения.  
Дана сигнатура функции: `String makeDecision (int x, int y);`  
Необходимо реализовать функцию таким образом, чтобы она возвращала  
строку, которая включает два принятых функцией числа и корректно  
выставленный знак операции сравнения (больше, меньше, или равно).  
Пример 1:
```
x=5 y=7
результат: “5< 7”
```
Пример 2:
```
x=8 y=-1
результат: “8 >-1”
```
Пример 3:
```
x=4 y=4
результат: “4==4”
```

### Алгоритм решения
1. Сравниваю числа и определяю знак сравнения между ними
2. Возвращаю строку из чисел и знака сравнения

### Тесты
```
makeDecision(23,23) == L"23==23"; // true
makeDecision(23,3) == L"23>3"; // true
makeDecision(3,23) == L"3<23"; // true
```



# task16/

# Лабораторная работа №1 Вариант 6
## Задание 2.6 Условия


### Постановка задачи
Тройная сумма.  
Дана сигнатура функции: `bool sum3 (int x, int y, int z);`  
Необходимо реализовать функцию таким образом, чтобы она возвращала `true`,  
если два любых числа (из трех принятых) можно сложить так, чтобы получить  
третье.  
Пример 1:  
```
x=5 y=7 z=2  
результат: true  
```
Пример 2:  
```
x=8 y=-1 z=4  
результат: false  
```

### Алгоритм решения
1. Проверяю все возможные комбинации сложения двух чисел из трех:
   - x + y == z
   - x + z == y  
   - y + z == x
2. Если хотя бы одно из условий выполняется, возвращаю true
3. Иначе, возвращаю false

### Тесты
```
sum3(5,7,2) == true; // true
sum3(8,-1,4) == false; // true
```



# task18/

# Лабораторная работа №1 Вариант 6
## Задание 2.8 Условия


### Постановка задачи
Возраст.  
Дана сигнатура функции: `String age (int x);`  
Необходимо реализовать функцию таким образом, чтобы она возвращала  
строку, в которой сначала будет число х, а затем одно из слов:  
• год  
• года  
• лет  
Слово “год” добавляется, если число х заканчивается на 1, кроме числа 11.  
Слово “года” добавляется, если число х заканчивается на 2, 3 или 4, кроме чисел 12, 13, 14.  
Слово “лет” добавляется во всех остальных случаях.  
Подсказка: оператор % позволяет получить остаток от деления.  
Пример 1:  
```
x=5
результат: “5 лет”
```
Пример 2:  
```
x=31
результат: “31 год”
```
Пример 3:  
```
x=44
результат: “44 года”
```

### Алгоритм решения
1. Проверяю данные в задаче условия, выбирая возвращаемую строку

### Тесты
```
age(11) == "11 лет"; // true
age(22) == "22 года"; // true
age(31) == "31 год"; // true
```


# task20/

# Лабораторная работа №1 Вариант 6
## Задание 2.10 Условия


### Постановка задачи
Вывод дней недели.  
Дана сигнатура функции: `void printDays (int x);`  
В качестве параметра функция принимает число x, обозначаются день недели.  
Необходимо реализовать функцию таким образом, чтобы она выводила на  
экран название переданного в него дня и всех последующих до конца недели  
дней. Если в качестве параметра передан не день (число, не в диапазоне от 1 от  
7), то выводится текст “это не день недели”. Первый день понедельник,  
последний – воскресенье. Вместо if в данной задаче используйте switch.  
Пример 1:  
```
x=4
результат:
четверг
пятница
суббота
воскресенье
```
Пример 2:  
```
x=18
результат:
это не день недели
```

### Алгоритм решения
1. Используем оператор switch:
   - если x от 1 до 7 - вывожу соответствующий день недели
   - из-за отсутствия break после каждого case автоматически выводятся все последующие случаи
2. Если x не попадает в диапазон, выполняется ветка default выводящая сообщение "это не день недели"

### Тесты
```
printDays(4);
// Четверг
// Пятница
// Суббота
// Воскресенье
```



# task22/

# Лабораторная работа №1 Вариант 6
## Задание 3.2 Циклы


### Постановка задачи
Числа наоборот.  
Дана сигнатура функции: `String reverseListNums (int x);`  
Необходимо реализовать функцию таким образом, чтобы она возвращала  
строку, в которой будут записаны все числа от x до 0 (включительно).  
Пример:  
```
x=5
результат: “5 4 3 2 1 0”
```

### Алгоритм решения
1. Если x равен 0, сразу возвращаю пустую строку "".
2. Если x положительное,
   - начинаю цикл от x до 0 с шагом -1, добавляя числа в строку
3. Если x отрицательное,
   - начинаю цикл от x до 0 с шагом +1, добавляя числа в строку

### Тесты
```
reverseListNums(3) == "3 2 1 0"; // true
reverseListNums(-2) == "-2 -1 0"; // true
reverseListNums(0) == ""; // true
```



# task24/

# Лабораторная работа №1 Вариант 6
## Задание 3.4 Циклы


### Постановка задачи
Степень числа.  
Дана сигнатура функции: `int pow (int x, int y);`  
Необходимо реализовать функцию таким образом, чтобы она возвращала  
результат возведения x в степень y.  
Подсказка: для получения степени необходимо умножить единицу на число x,  
и сделать это y раз, т.е. два в третьей степени это 1*2*2*2  
Пример:  
```
x=2
y=5
результат: 32
```

### Алгоритм решения
1. Запускаю цикл, который выполняется y раз.
2. В каждой итерации умножаю result на x.

### Тесты
```
pow(2, 3) == 8; // true
pow(5, 0) == 1; // true
pow(2, -3) == 0; // true
pow(-2, 3) == -8 // true
```



# task26/

# Лабораторная работа №1 Вариант 6
## Задание 3.6 Циклы


### Постановка задачи
Одинаковость.  
Дана сигнатура функции: `bool equalNum (int x);`  
Необходимо реализовать функцию таким образом, чтобы она возвращала `true`,  
если все знаки числа одинаковы, и `false` в ином случае.  
  
Подсказки:
```  
intx=123%10; // х будет иметь значение 3  
intу=123/10; // у будет иметь значение 12  
```
Пример 1:  
```
x=1111  
результат: true  
```
Пример 2:  
```
x=1211  
результат: false  
```

### Алгоритм решения
1. Если число отрицательное, делаю его положительным (x = -x)  
2. Получаю последнюю цифру числа: lastDigit = x % 10  
3. В цикле проверяю каждую цифру числа:  
   - Получаю текущую цифру: x % 10  
   - Сравниваю её с сохранённой последней цифрой  
   - Если цифры не равны, возвращаю false  
   - Убираю последнюю цифру: x /= 10  
4. Если все цифры одинаковы, возвращаю true  

### Тесты
```
equalNum(1111) == true; // true
equalNum(1211) == false; // true
equalNum(0) == true; // true
```



# task28/

# Лабораторная работа №1 Вариант 6
## Задание 3.8 Циклы


### Постановка задачи
Левый треугольник.  
Дана сигнатура функции: `void leftTriangle (int x);`  
Необходимо реализовать функцию таким образом, чтобы она выводила на  
экран треугольник из символов ‘*’ у которого х символов в высоту, а количество  
символов в ряду совпадает с номером строки.  
Пример 1:  
```
x=2
результат:
*
**
```
Пример 2:  
```
x=4
результат:
*
**
***
****
```

### Алгоритм решения
1. Запускаю внешний цикл i от 1 до x по строкам.
2. Внутренним циклом j от 1 до i вывожу i звёздочек.

### Тесты
```
leftTriangle(4) \
   *
   **
   ***
   ****
```



# task30/

# Лабораторная работа №1 Вариант 6
## Задание 3.10 Циклы


### Постановка задачи
Угадайка.
Дана сигнатура функции: `void guessGame();`
Необходимо реализовать функцию таким образом, чтобы она генерировала
случайное число от 0 до 9, далее считывала с консоли введенное пользователем
число и выводила, угадал ли пользователь то, что было загадано, или нет.
Функция запускается до тех пор, пока пользователь не угадает число. После
этого выведите на экран количество попыток, которое потребовалось
пользователю, чтобы угадать число.
Пример:
```
Введите число от 0 до 9:
5
Вы не угадали, введите число от 0 до 9:
9
Вы угадали!
Вы отгадали число за 2 попытки
```

### Алгоритм решения
1. Генерирую случайное число от 0 до 9 и сохраняю его
2. Устанавливаю счётчик попыток
3. В цикле:
- запрашиваю у пользователя число
- если введённое число совпадает с случайным, вывожу сообщение об успехе и количество попыток
- иначе вывожу сообщение "Неверно, попробуйте ещё раз!"

### Тесты
```
guessGame() \
   Введите число от 0 до 9: 1
   Неверно, попробуйте ещё раз!
   Введите число от 0 до 9: 2
   Неверно, попробуйте ещё раз!
   Введите число от 0 до 9: 3
   Вы угадали!
   Вы отгадали число за 3 попыток(и)
```



# task32/

# Лабораторная работа №1 Вариант 6
## Задание 4.2 Массивы


### Постановка задачи
Поиск последнего значения.  
Дана сигнатура функции: `int findLast (int arr[], int x);`  
Необходимо реализовать функцию таким образом, чтобы она возвращала индекс  
последнего вхождения числа x в массив arr. Если число не входит в массив –  
возвращается -1.  
Пример:  
```
arr=[1,2,3,4,2,2,5]
x=2
результат: 5
```

### Алгоритм решения
1. Перебираю массив от начала до конца.
2. Если текущий элемент равен x, обновляю index этим номером.
3. После прохода по всему массиву:
   - если число встречалось - возвращаю index,
   - если не встречалось - возвращаю -1

### Тесты
```
arr = [1, 2, 3, 4, 5, 2];

findLast(arr, 5, 2) == 5; // true
findLast(arr, 5, 3) == 2; // true
findLast(arr, 5, 9) == -1; // true
```



# task34/

# Лабораторная работа №1 Вариант 6
## Задание 4.4 Массивы


### Постановка задачи
Добавление в массив.  
Дана сигнатура функции: `int * add (int arr[], int x, int pos);`  
Необходимо реализовать функцию таким образом, чтобы она возвращала новый  
массив, который будет содержать все элементы массива arr, однако в позицию pos  
будет вставлено значение x.  
Пример:
```
arr=[1,2,3,4,5]
x=9
pos=3
результат: [1,2,3,9,4,5]
```

### Алгоритм решения
1. Создаю новый массив длиной size + 1
2. Перебираю индексы i от 0 до size:
   - если i == pos, вставляю число x
   - иначе копирую элементы из старого массива
3. Возвращаю указатель на новый массив и очищаю память в конце программы

### Тесты
```
arr = [1, 2, 3, 4, 5]

add(arr, 5, 9, 3) → [1, 2, 3, 9, 4, 5]
add(arr, 5, 10, 0) → [10, 1, 2, 3, 4, 5]
add(arr, 5, 99, 5) → [1, 2, 3, 4, 5, 99]
```



# task36/

# Лабораторная работа №1 Вариант 6
## Задание 4.6 Массивы


### Постановка задачи
Реверс.  
Дана сигнатура функции: `void reverse (int arr[]);`  
Необходимо реализовать функцию таким образом, чтобы он изменял массив `arr`.  
После проведенных изменений массив должен быть записан задом-наперед.  
Пример:  
```
arr=[1,2,3,4,5]  
результат: arr=[5,4,3,2,1]  
```

### Алгоритм решения
1. Определяю размер массива: n = arr.size()  
2. В цикле прохожу от начала до середины массива (i < n / 2):  
   - Меняю местами элементы arr[i] и arr[n - i - 1]  
   - Использую функцию std::swap для обмена значений  
3. После завершения цикла массив будет развёрнут задом-наперёд  

### Тесты
```
reverse([1, 2, 3]) == [3, 2, 1]; // true
reverse([1]) == [1]; // true
reverse([5, 4, 4, 6]) == [6, 4, 4, 5]; // true
```



# task38/

# Лабораторная работа №1 Вариант 6
## Задание 4.8 Массивы


### Постановка задачи
Объединение.  
Дана сигнатура функции: `int * concat (int arr1[],int arr2[]);`  
Необходимо реализовать функцию таким образом, чтобы она возвращала новый  
массив, в котором сначала идут элементы первого массива (arr1), а затем второго  
(arr2).  
Пример:  
```
arr1=[1,2,3]
arr2=[7,8,9]
результат: [1,2,3,7,8,9]
```

### Алгоритм решения
1. Считываю строки чисел
2. Вызываю concat(arr1, size1, arr2, size2), которая создаёт новый объединённый массив
3. Освобождаю память

### Тесты
```
concat([1,2,3], 3, [7,8,9], 3) == [1, 2, 3, 7, 8, 9]; // true
concat([1], 1, [2], 1) == [1, 2]; // true
```


# task40/

# Лабораторная работа №1 Вариант 6
## Задание 4.10 Массивы


### Постановка задачи
Удалить негатив.  
Дана сигнатура функции: `int * deleteNegative (int arr[]);`  
Необходимо реализовать функцию таким образом, чтобы она возвращала новый  
массив, в котором записаны все элементы массива arr кроме отрицательных.  
Пример:  
```
arr=[1,2,-3,4,-2,2,-5]
результат: [1,2,4,2]
```

### Алгоритм решения
1. Подсчитываю, сколько чисел в массиве неотрицательные (>= 0)
2. Создаю новый массив нужного размера
3. Копирую туда только положительные и нулевые элементы

### Тесты
```
deleteNegative([1,2,-3,4,-2,2,-5]) == [1,2,4,2]; // true
deleteNegative([1,2,3]) == [1,2,3]; // true
deleteNegative([-1]) == []; // true
```
