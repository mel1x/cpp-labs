# Лабораторная работа №5 Жукова Михила ИТ-1-2024 Вариант 6


## Задание 1.6 Бинарные файлы

### Постановка задачи
Переписать в другой файл последовательного доступа те элементы, которые кратны k.

Исходный бинарный файл необходимо заполнить случайными данными, заполнение организовать отдельным методом.

### Алгоритм решения
1. Создаём класс `Task1` с полями `inFilename` и `outFilename` для хранения имён файлов
2. Реализуем метод `fillFile(count, minValue, maxValue)`:
   - Удаляем старый файл, если он существует
   - Создаём новый бинарный файл
   - Генерируем случайные числа в диапазоне [minValue, maxValue]
   - Записываем числа в бинарный файл с помощью `write()`
3. Реализуем метод `copyMultiplesOfK(k)`:
   - Открываем исходный бинарный файл для чтения
   - Создаём новый бинарный файл для записи
   - Последовательно читаем числа из исходного файла
   - Проверяем условие: если `number % k == 0`, то записываем число в новый файл
   - Выводим статистику скопированных элементов
4. Реализуем метод `printFile(filename)` для отображения содержимого бинарного файла

### Тесты
```
Создан новый файл task1.bin
Записываем 10 случайных чисел:
8 3 5 6 9 2 4 7 0 1

Введите k: 2

Создан файл task1_out.bin
Числа, кратные 2:
8 6 2 4 0

Скопировано чисел: 5
Результат сохранён в файл task1_out.bin
```


## Задание 2.6 Бинарные файлы

### Постановка задачи
Скопировать элементы заданного файла в квадратную матрицу размером n×n (если элементов файла недостает, заполнить оставшиеся элементы матрицы нулями). Заменить все столбцы на столбец с минимальной суммой элементов.

### Алгоритм решения
1. Создаём класс `Task2` с полями `filename`, `n` (размер матрицы) и `matrix` (двумерный вектор)
2. Реализуем метод `fillFile(count, minValue, maxValue)`:
   - Создаём бинарный файл со случайными числами
3. Реализуем метод `loadMatrix()`:
   - Читаем числа из бинарного файла последовательно
   - Заполняем матрицу построчно: matrix[i][j]
   - Если элементов не хватает, оставшиеся ячейки остаются нулями
4. Реализуем метод `getColumnSum(col)`:
   - Вычисляем сумму элементов в заданном столбце
5. Реализуем метод `findMinSumColumn()`:
   - Перебираем все столбцы и вычисляем их суммы
   - Находим столбец с минимальной суммой
   - Возвращаем индекс этого столбца
6. Реализуем метод `replaceColumns()`:
   - Находим столбец с минимальной суммой
   - Копируем этот столбец во временный массив
   - Заменяем все столбцы матрицы на сохранённый столбец
7. Реализуем метод `printMatrix()` для вывода матрицы на экран

### Тесты
```
Загрузка данных из файла в матрицу 5 × 5
Загружено элементов: 22
Недостающие элементы заполнены нулями

Матрица 5 × 5:
    8    3    5    6    9
    2    4    7    0    1
    3    8    2    5    0
    0    0    0    0    0
    0    0    0    0    0

Суммы столбцов:
Столбец 0: 13
Столбец 1: 15
Столбец 2: 14
Столбец 3: 11
Столбец 4: 10

Столбец с минимальной суммой: 4 (сумма = 10)

Все столбцы заменены на столбец с минимальной суммой

Матрица 5 × 5:
    9    9    9    9    9
    1    1    1    1    1
    0    0    0    0    0
    0    0    0    0    0
    0    0    0    0    0
```


## Задание 3.6 Бинарные файлы и структуры

### Постановка задачи
Файл содержит сведения об игрушках: название игрушки, ее стоимость в рублях и возрастные границы (например, игрушка может предназначаться для детей от двух до пяти лет). Определить стоимость самого дорогого конструктора.

### Алгоритм решения
1. Создаём структуру `Toy`:
   - `wchar_t name[50]` - название игрушки
   - `double price` - стоимость в рублях
   - `int minAge` - минимальный возраст
   - `int maxAge` - максимальный возраст
2. Создаём класс `Task3` с полем `filename` и вектором `toys`
3. Реализуем метод `fillFile()`:
   - Создаём файл с примерами игрушек
   - Добавляем различные конструкторы с разными ценами
   - Записываем структуры в бинарный файл с помощью `write()`
4. Реализуем метод `addToy(name, price, minAge, maxAge)`:
   - Создаём структуру Toy с переданными параметрами
   - Добавляем игрушку в конец файла (режим `ios::app`)
5. Реализуем метод `loadToys()`:
   - Читаем все структуры из файла в вектор toys
6. Реализуем метод `findMostExpensive(result)`:
   - Загружаем все игрушки из файла
   - Перебираем игрушки и ищем конструкторы (проверяем наличие слова "конструктор" в названии)
   - Используем функцию `towlower()` для приведения к нижнему регистру
   - Сравниваем цены и сохраняем самый дорогой конструктор
   - Возвращаем `true`, если конструктор найден, иначе `false`
7. Реализуем методы `printToy()` и `printAllToys()` для вывода информации

### Тесты
```
Создан новый файл task3.bin
Добавление игрушек в файл:
  - Мяч - 350.5 руб, от 3 До 14 лет
  - Конструктор LEGO - 4500 руб, от 2 До 12 лет
  - Кукла Барби - 2200 руб, от 3 До 8 лет
  - Конструктор особняк - 2300 руб, от 3 До 12 лет
  - Радиоуправляемая машина - 5500 руб, от 5 До 14 лет
  - Конструктор 'Звезда смерти' - 14200 руб, от 4 До 12 лет
  - Мишка - 1650 руб, от 0 До 5 лет
  - Конструктор самолет - 1500 руб, от 2 До 8 лет

Всего добавлено игрушек: 8

Поиск самого дорогого конструктора:

Найден самый дорогой конструктор:

  Название: Конструктор 'Звезда смерти'
  Стоимость: 14200 руб.
  Возраст: от 4 до 12 лет
```


## Задание 4.6 Текстовые файлы

### Постановка задачи
Найти сумму тех элементов файла, которые равны своему индексу (индексацию элементов файла в этой задаче начинать с нуля).

В текстовом файле хранятся целые числа по одному в строке, исходный файл необходимо заполнить случайными данными, заполнение организовать отдельным методом.

### Алгоритм решения
1. Создаём класс `Task4` с полем `filename` и вектором `numbers`
2. Реализуем метод `fillFile(count, minValue, maxValue)`:
   - Создаём текстовый файл с помощью `wofstream`
   - Генерируем случайные числа
   - Записываем числа по одному в строке с помощью `endl`
3. Реализуем метод `loadNumbers()`:
   - Открываем текстовый файл с помощью `wifstream`
   - Считываем числа из файла в вектор: `while (file >> number)`
4. Реализуем метод `findSum()`:
   - Загружаем числа из файла
   - Перебираем элементы вектора с индексами: `for (size_t i = 0; i < numbers.size(); i++)`
   - Проверяем условие: если `numbers[i] == static_cast<int>(i)`, добавляем элемент к сумме
   - Выводим все найденные элементы и итоговую сумму
5. Реализуем метод `printIndexes()` для отображения таблицы сравнения индексов и значений
6. Реализуем метод `printFile()` для вывода содержимого файла

### Тесты
```
Создан новый файл task4.txt
Записываем 20 случайных чисел:
0 8 3 5 4 9 2 7 6 1 0 3 8 5 2 7 4 9 6 1

Поиск элементов, равных своему индексу:

 Индекс 0, число: 0
 Индекс 4, число: 4

Найдено элементов: 2
Сумма этих элементов: 4

Сравнение чисел с индексами:
  Индекс | Число | Совпадение
  ------------------------
       0 |     0 |   Да
       1 |     8 |   нет
       2 |     3 |   нет
       3 |     5 |   нет
       4 |     4 |   Да
       5 |     9 |   нет
       ...
```


## Задание 5.6 Текстовые файлы

### Постановка задачи
Вычислить произведение элементов, которые кратны заданному числу k.

В текстовом файле хранятся целые числа по несколько в строке, исходный файл необходимо заполнить случайными данными, заполнение организовать отдельным методом.

### Алгоритм решения
1. Создаём класс `Task5` с полем `filename` и вектором `numbers`
2. Реализуем метод `fillFile(totalCount, numbersPerLine, minValue, maxValue)`:
   - Создаём текстовый файл с помощью `wofstream`
   - Генерируем случайные числа
   - Записываем числа по несколько в строке:
     - После каждых `numbersPerLine` чисел добавляем `endl`
     - Между числами в строке добавляем пробел
3. Реализуем метод `loadNumbers()`:
   - Открываем текстовый файл
   - Считываем все числа в вектор (автоматически игнорируются переносы строк)
4. Реализуем метод `calculateMult(k)`:
   - Проверяем, что k ≠ 0 (деление на ноль)
   - Загружаем числа из файла
   - Инициализируем `product = 1` и `count = 0`
   - Перебираем все числа: если `num % k == 0`, умножаем product на num
   - Возвращаем произведение (или 0, если ничего не найдено)
5. Реализуем метод `printNumbers(k)` для вывода всех чисел с пометкой кратности
6. Реализуем метод `printFile()` для вывода файла построчно

### Тесты
```
Создан новый файл task5.txt
Записываем 10 чисел, по 3 в строке:

2 6 4
8 3 9
5 0 7
1

Введите k: 2

Поиск чисел, кратных 2:

  2 кратно: 2
  6 кратно: 2
  4 кратно: 2
  8 кратно: 2
  0 кратно: 2

Найдено чисел: 5
Произведение: 0

(Примечание: произведение равно 0, так как в последовательности есть 0)
```


## Задание 6.6 Текстовые файлы

### Постановка задачи
Переписать в другой файл строки, в которых нет русских букв.

В файле хранится произвольный текст.

### Алгоритм решения
1. Создаём класс `Task6` с полями `inFilename` и `outFilename`
2. Реализуем вспомогательный метод `isRuLetter(ch)`:
   - Проверяем, является ли символ русской буквой
   - Используем диапазоны Unicode: 0x0410-0x044F (А-Я, а-я)
   - Добавляем проверку для букв Ё (0x0401) и ё (0x0451)
3. Реализуем метод `containsRuLetters(line)`:
   - Перебираем все символы строки
   - Возвращаем `true`, если хотя бы один символ - русская буква
4. Реализуем метод `createFile()`:
   - Создаём текстовый файл с примерами строк
   - Добавляем строки на русском, английском, смешанные и с цифрами
   - Используем `file.imbue(locale(""))` для корректной работы с Unicode
5. Реализуем метод `addFileLine(line)`:
   - Открываем файл в режиме добавления (`ios::app`)
   - Добавляем новую строку в конец файла
6. Реализуем метод `copyLines()`:
   - Открываем исходный файл для чтения
   - Создаём новый файл для записи
   - Считываем строки с помощью `getline()`
   - Для каждой строки проверяем наличие русских букв
   - Если русских букв нет, копируем строку в новый файл
   - Выводим статистику обработки
7. Реализуем метод `printFile(filename)` для вывода содержимого файла

### Тесты
```
Создан новый файл task6.txt
Добавление примеров строк:

  Hello World
  Привет мир
  123456789
  Dota2 good game
  Смешанный englesh текст
  Numbers 100
  спец символы *!@#%^&
  Это полностью русская строка
  Ещё одна строка с буквой ё
  again eng line

  CPP LABA NOVAYA

Копирование строк без русских букв...

 Скопировано: Hello World
 Пропущено: Привет мир
 Скопировано: 123456789
 Скопировано: Dota2 good game
 Пропущено: Смешанный englesh текст
 Скопировано: Numbers 100
 Пропущено: спец символы *!@#%^&
 Пропущено: Это полностью русская строка
 Пропущено: Ещё одна строка с буквой ё
 Скопировано: again eng line
 Скопировано: (пустая строка)
 Скопировано: CPP LABA NOVAYA

Обработка завершена
Скопировано строк: 7
Пропущено строк: 5
Результат сохранён в файл task6_out.txt
```
