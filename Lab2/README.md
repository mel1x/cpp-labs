# Лабораторнаяработа №1 Жукова Михила ИТ-1-2024 Вариант 6

# task1/

# Лабораторная работа №2 Вариант 6
## Задание 1.4 Заполнение и доступ к элементам. Обратные итераторы.


### Постановка задачи
Дан набор целых чисел с четным количеством элементов. Заполнить дек D исходными числами,
вывести первую половину элементов дека D в обратном порядке, а затем — вторую половину
(также в обратном порядке).

### Алгоритм решения
1. Создаем контейнер deque и заполняем его числами
2. Определяем итератор для прохода по деку
3. Проходим одним обратным итератором по деку и выводим 2 половины


### Тесты
```
printSides({1, 2, 3, 4}, 4);
    Первая половина в обратном порядке:
    4 3
    Вторая половина в обратном порядке:
    2 1
```



# task2/

# Лабораторная работа №2 Вариант 6
## Задание 2.7 Вставка элементов


### Постановка задачи
Дан вектор V. Вставить после каждого элемента исходного вектора число − 1. Использовать
функцию-член insert в цикле с параметром-итератором.
Указание. Организуйте перебор элементов вектора в цикле с параметром-итератором i.
Вставку выполняйте в позицию ++i, обязательно присваивая параметру i значение,
возвращаемое функцией-членом insert.

### Алгоритм решения
1. Используем итератор для перебора элементов вектора
2. Используя метод insert вставляем 1 после каждого числа, обновляя итератор


### Тесты
```
formatVector(v{1, 2, 3, 4}) == v{1, 1, 2, 1, 3, 1, 4, 1}; // true
formatVector(v{3, 3, 3}) == v{3, 1, 3, 1, 3, 1}; // true
formatVector(v{4}) == v{4, 1}; // true
```



# task3/

# Лабораторная работа №2 Вариант 6
## Задание 3.1 Удаление элементов


### Постановка задачи
Дан дек D с нечетным количеством элементов N(≥3). Удалить средний элемент дека.
Использовать функцию-член erase.

### Алгоритм решения
1. Определяю индекс среднего элемента как Deck.size() / 2
2. Удаляю средний элемент методом итератора erase


### Тесты
```
removeMid({1, 2, 3}) == {1, 3}; // true
removeMid({1, 2, 3, 4, 5}) == {1, 2, 4, 5}; // true
```



# task4/

# Лабораторная работа №2 Вариант 6
## Задание 4.7 Итераторы и алгоритмы


### Постановка задачи
Дана строка name и целое число K (> 0). Записать в текстовый файл с именем name K символов
«*». Использовать алгоритм fill_n.

### Алгоритм решения
1. Создаём стрим вывода в файл с название name и проверяем на ошибки
2. Используя fill_n передаём итератор указывающий на первый символ файла, кол-во символов и символ *
3. Закрываем файл


### Тесты
```
createStarsFile("stars", 4);
# /stars
# ****

createStarsFile("stars2", 1);
# /stars2
# *
```



# task5/

# Лабораторная работа №2 Вариант 6
## Задание 5.6 Алгоритмы поиска


### Постановка задачи
Даны вектор V и список L; вектор V имеет четное количество элементов. Продублировать
последний элемент списка, совпадающий с каким-либо элементом из первой половины
исходного вектора. Если список не содержит требуемых элементов, то не изменять его.
Использовать алгоритм find_first_of и функцию-член insert для списка.

### Алгоритм решения
1. Разбиваем вектор на первую половину
2. Используем find_first_of, чтобы найти первое совпадение из первой половины вектора в списке
3. После первого совпадения продолжаем искать все остальные совпадения, чтобы найти последнее вхождение
4. Дублируем найденный элемент с помощью insert() после его последнего вхождения

### Тесты
```
duplicateLastMatch(v{1, 2, 3, 4}, {6, 7, 8, 2, 3, 1}) == {6, 7, 8, 2, 3, 1, 1}; // true
duplicateLastMatch(v{1, 2, 3, 4}, {6, 7, 8, 2, 3}) == {6, 7, 8, 2, 3}; // true
```



# task6/

# Лабораторная работа №2 Вариант 6
## Задание 6.6 Базовые модифицирующие алгоритмы. Итераторы вставки.


### Постановка задачи
Дано число K (0 < K < 10) и списки L1 и L2, каждый из которых содержит не менее 10 элементов.
Выполнить для списка L1 циклический сдвиг элементов вправо на K позиций, а для списка L2 —
циклический сдвиг влево на K позиций. Использовать алгоритм rotate и функцию advance.

### Алгоритм решения
1. Для сдвига вправо (L1):
    - Используем rotate() с обратными итераторами: начинаем с rbegin(), точка поворота - std::next(rbegin(), K), конец - rend()
2. Для сдвига влево (L2):
    - Используем rotate() с прямыми итераторами: начинаем с begin(), точка поворота - std::next(begin(), K), конец - end()

### Тесты
```
rotateRight({1, 2, 3, 4}, 2) == {3, 4, 1, 2}; // true
rotateLeft({1, 2, 3, 4}, 1) == {2, 3, 4, 1}; // true
```



# task7/

# Лабораторная работа №2 Вариант 6
## Задание 7.3 Сортировка и слияние


### Постановка задачи
Дан вектор V, содержащий не менее 3 элементов. Определить значения трех конечных
элементов вектора после того, как вектор будет отсортирован (по возрастанию) и вывести их в
порядке убывания. Использовать один вызов алгоритма partial_sort с параметром —
функциональным объектом greater и алгоритм copy для вывода требуемых элементов.

### Алгоритм решения
1. Используя partial_sort сортирую вектор, получая на первых 3х местах, наибольшие элементы
2. Копирую первые 3 элемента вектора после сортировки в поток вывода

### Тесты
```
printLastThree(v{1, 2, 3, 4, 5});
    Исходный вектор V: 
    1 2 3 4 5 
    Три наибольших элемента вектора в порядке убывания: 
    5 4 3
```



# task8/

# Лабораторная работа №2 Вариант 6
## Задание 8.1 Численные алгоритмы


### Постановка задачи
Дан список L. Получить вектор V вещественных чисел, содержащий значения среднего
арифметического для всех пар соседних элементов исходного списка (количество элементов
вектора V должно быть на 1 меньше количества элементов списка L). Например, для исходного
списка 1, 3, 4, 6 полученный вектор должен содержать значения 2.0, 3.5, 5.0. Использовать
алгоритм adjacent_difference с итератором вставки и функциональным объектом, а также
функцию-член erase для вектора V.

### Алгоритм решения
1. Через adjacent_difference обрабатываю пары в формуле (a + b) / 2.0 и генерирую вставки в конце вектора V
2. Удаляю первый элемент вектора через erase, так как он содержит копию первого элемента

### Тесты
```
computeAverage({1, 2, 3, 4});
    Исходный список L: 
    1 2 3 4 
    Вектор V, содержащий среднее арифметическое для всех пар соседних элементов: 
    1,5 2,5 3,5 
```



# task9/

# Лабораторная работа №2 Вариант 6
## Задание 9.1 Множества


### Постановка задачи
Дан вектор V0, целое число N (> 0) и набор векторов V1, …, VN. Известно, что размер вектора V0
не превосходит размера любого из векторов V1, …, VN. Найти количество векторов VI, I = 1, …, N,
в которых содержатся все элементы вектора V0 (без учета их повторений). Использовать
алгоритм includes, применяя его в цикле к двум множествам, одно из которых создано на основе
вектора V0, а другое на очередной итерации содержит элементы очередного из векторов VI, I =
1, …, N.

### Алгоритм решения
1. Создаю множество на основе вектора V0 (оно автоматически отсортированно)
2. Получаю вектора VI, создаю из них множества и сравниваю с множество V0 через includes

### Тесты
Пример выполнения:
```

Введите размер вектора V0: 3
Введите элементы вектора V0:
V0[0]: 1
V0[1]: 2
V0[2]: 3
Введите количество векторов N: 2

Вектор V1:
Введите размер вектора V1: 3
Введите элементы вектора V1:
V1[0]: 2
V1[1]: 2
V1[2]: 2
Вектор V1 НЕ содержит все элементы V0

Вектор V2:
Введите размер вектора V2: 3
Введите элементы вектора V2:
V2[0]: 1
V2[1]: 2
V2[2]: 3
Вектор V2 содержит все элементы V0

========================================
Количество векторов, содержащих все элементы V0: 1
```


# task10/

# Лабораторная работа №2 Вариант 6
## Задание 10.2 Отображения


### Постановка задачи
Дан вектор V, элементами которого являются английские слова, набранные заглавными
буквами. Определить суммарную длину слов, начинающихся с одной и той же буквы, и вывести
все различные буквы, с которых начинаются элементы вектора V, вместе с суммарной длиной
этих элементов (в алфавитном порядке букв); длину выводить сразу после соответствующей
буквы. Использовать вспомогательное отображение M, ключами которого являются начальные
буквы элементов вектора V, а значениями — суммарная длина этих элементов. При заполнении
отображения M не использовать условные конструкции (достаточно операций индексирования
[], инкремента и функции-члена size для строк). Элементы вектора V (при заполнении
отображения M) и элементы отображения M (при выводе полученных результатов) перебирать
в цикле с параметром-итератором соответствующего контейнера.

### Алгоритм решения
1. Считываю N слов в вектор V с проверкой, что каждое слово содержит только заглавные английские буквы
2. Создаю отображение M типа map<char, size_t>
3. Проходим по вектору V с помощью итератора и для каждого слова добавляю его длинну в отображение

### Тесты
```
// Входные данные:
V = {"APPLE", "AVOCADO", "BANANA", "BERRY", "CHERRY"}

// Результаты:
A11
B11
C6

// Пояснение:
// A: APPLE(5) + AVOCADO(7) = 12
// B: BANANA(6) + BERRY(5) = 11
// C: CHERRY(6) = 6
```